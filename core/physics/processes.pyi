import numpy as np
from abc import ABC, abstractmethod
from typing import Optional, Any, Tuple, Union, Generic
from numpy.typing import NDArray
from core.materials.attenuation_functions import AttenuationFunction
from core.particles.particles import Particle, ParticleArray
from core.materials.materials import Material, MaterialArray
from core.other.typing_definitions import Energy, Vector3D, Precision

class Process(ABC, Generic[Precision]):
    rng: np.random.Generator
    _energy_range: NDArray[np.float64]
    attenuation_function: AttenuationFunction
    def __init__(self, attenuation_database: Optional[Any] = None, rng: Optional[np.random.Generator] = None) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def energy_range(self) -> NDArray[np.float64]: ...
    @energy_range.setter
    def energy_range(self, value: NDArray[np.float64]) -> None: ...
    def get_LAC(self, particle: Union[Particle, ParticleArray[Precision]], material: Union[Material, MaterialArray]) -> Any: ...
    def generate_free_path(self, particle: Union[Particle, ParticleArray[Precision]], material: Union[Material, MaterialArray]) -> Any: ...
    def __call__(self, particle: Union[Particle, ParticleArray[Precision]], material: Union[Material, MaterialArray]) -> np.recarray: ...

class PhotoelectricEffect(Process[Precision]): ...

class CoherentScattering(Process[Precision]):
    theta_generator: Any
    def generate_theta(self, particle: Union[Particle, ParticleArray[Precision]], material: Union[Material, MaterialArray]) -> NDArray[np.float64]: ...
    def generate_phi(self, size: int) -> NDArray[np.float64]: ...

class ComptonScattering(CoherentScattering[Precision]):
    def culculate_energy_deposit(self, theta: NDArray[np.float64], particle_energy: NDArray[np.float64]) -> NDArray[np.float64]: ...

class PairProduction(Process[Precision]): ...

process_data_dtype: np.dtype
