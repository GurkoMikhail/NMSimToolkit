import numpy as np
from typing import List, Any, Optional, Tuple, Union, Type, TypeVar, Sequence
from numpy.typing import NDArray
from core.geometry.geometries import Geometry
from core.materials.materials import Material, MaterialArray
from core.other.nonunique_array import NonuniqueArray
from core.other.typing_definitions import Vector3D, Length, Precision

T = TypeVar('T')

class ElementaryVolume:
    geometry: Geometry
    material: Material
    name: str
    def __init__(self, geometry: Geometry, material: Material, name: Optional[str] = None) -> None: ...
    @property
    def size(self) -> Vector3D: ...
    @size.setter
    def size(self, value: Vector3D) -> None: ...
    def dublicate(self) -> 'ElementaryVolume': ...
    def check_inside(self, position: Vector3D) -> Union[bool, NDArray[np.bool_]]: ...
    def check_outside(self, position: Vector3D) -> Union[bool, NDArray[np.bool_]]: ...
    def cast_path(self, position: Vector3D, direction: Vector3D) -> Tuple[NDArray[Precision], 'VolumeArray']: ...
    def get_material_by_position(self, position: Vector3D) -> MaterialArray: ...

class VolumeWithChilds(ElementaryVolume):
    childs: List['TransformableVolume']
    def __init__(self, geometry: Geometry, material: Material, name: Optional[str] = None) -> None: ...
    def add_child(self, child: 'TransformableVolume') -> None: ...

class TransformableVolume(ElementaryVolume):
    transformation_matrix: NDArray[np.float64]
    parent: Optional[VolumeWithChilds]
    def __init__(self, geometry: Geometry, material: Material, name: Optional[str] = None) -> None: ...
    @property
    def total_transformation_matrix(self) -> NDArray[np.float64]: ...
    def convert_to_local_position(self, position: Vector3D, as_parent: bool = True) -> Vector3D: ...
    def convert_to_local_direction(self, direction: Vector3D, as_parent: bool = True) -> Vector3D: ...
    def translate(self, x: float = 0., y: float = 0., z: float = 0., inLocal: bool = False) -> None: ...
    def rotate(self, alpha: float = 0., beta: float = 0., gamma: float = 0., rotation_center: Sequence[float] = ..., inLocal: bool = False) -> None: ...
    def set_parent(self, parent: VolumeWithChilds) -> None: ...

class TransformableVolumeWithChild(TransformableVolume, VolumeWithChilds): ...

class VolumeArray(NonuniqueArray):
    element_list: List[Optional[ElementaryVolume]]
    @property
    def material(self) -> MaterialArray: ...
    def type_matching(self, type: Type[T]) -> NDArray[np.bool_]: ...
