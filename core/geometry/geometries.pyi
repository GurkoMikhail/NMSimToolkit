import numpy as np
from abc import ABC, abstractmethod
from typing import Union, Sequence, Tuple, Any, Generic
from numpy.typing import NDArray
from core.other.typing_definitions import Length, Vector3D, Precision

class Geometry(ABC, Generic[Precision]):
    size: Vector3D[Precision]
    def __init__(self, size: Union[Sequence[Length], Vector3D[Precision]]) -> None: ...
    @property
    def half_size(self) -> Vector3D[Precision]: ...
    @property
    def quarter_size(self) -> Vector3D[Precision]: ...
    @abstractmethod
    def check_outside(self, position: Vector3D[Precision]) -> Union[bool, NDArray[np.bool_]]: ...
    @abstractmethod
    def check_inside(self, position: Vector3D[Precision]) -> Union[bool, NDArray[np.bool_]]: ...
    @abstractmethod
    def cast_path(self, position: Vector3D[Precision], direction: Vector3D[Precision]) -> Tuple[NDArray[Precision], Union[bool, NDArray[np.bool_]]]: ...

class Box(Geometry[Precision]):
    distance_method: str
    distance_epsilon: Length
    def __init__(self, x: Length, y: Length, z: Length, **kwds: Any) -> None: ...
    def check_outside(self, position: Vector3D[Precision]) -> Union[bool, NDArray[np.bool_]]: ...
    def check_inside(self, position: Vector3D[Precision]) -> Union[bool, NDArray[np.bool_]]: ...
    def cast_path(self, position: Vector3D[Precision], direction: Vector3D[Precision]) -> Tuple[NDArray[Precision], Union[bool, NDArray[np.bool_]]]: ...
    def ray_marching(self, position: Vector3D[Precision], *args: Any) -> Tuple[NDArray[Precision], Union[bool, NDArray[np.bool_]]]: ...
    def ray_casting(self, position: Vector3D[Precision], direction: Vector3D[Precision]) -> Tuple[NDArray[Precision], Union[bool, NDArray[np.bool_]]]: ...
